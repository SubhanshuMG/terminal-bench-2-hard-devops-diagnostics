New Terminal Output:

root@c08cc3f8e638:/app# cat > /app/fix_toposort.py << 'EOF'
> #!/usr/bin/env python3
> from collections import deque
>
> def compute_startup_order_fixed(services: list) -> list:
>     """
>     Return a topologically sorted startup order using Kahn's algorithm.
>     Dependencies must start before the services that depend on them.
>     """
>     names = [s["name"] for s in services]
>     deps_map = {s["name"]: s.get("dependencies", []) for s in services}
>
>     graph     = {n: [] for n in names}
>     in_degree = {n: 0 for n in names}
>
>     # If A depends on B, then B must come before A
>     # So we add edge B -> A and increment A's in-degree
>     for svc, deps in deps_map.items():
>         for dep in deps:
>             graph[dep].append(svc)  # Edge from dependency to service
>             in_degree[svc] += 1   # Service depends on something
>
>     queue = deque(n for n in names if in_degree[n] == 0)
>     order = []
>     while queue:
>         node = queue.popleft()
>         order.append(node)
>         for neighbor in graph[node]:
>             in_degree[neighbor] -= 1
>             if in_degree[neighbor] == 0:
>                 queue.append(neighbor)
>     return order
>
> # Test with the same data
> services = [
>     {"name": "auth-service", "dependencies": []},
>     {"name": "api-gateway", "dependencies": ["auth-service", "cache-service"]},
>     {"name": "cache-service", "dependencies": []},
>     {"name": "worker-service", "dependencies": ["api-gateway", "cache-service"]},
>     {"name": "notification-service", "dependencies": ["worker-service"]},
> ]
>
> result = compute_startup_order_fixed(services)
> print("Correct startup order:", " -> ".join(result))
> EOF
root@c08cc3f8e638:/app# python /app/fix_toposort.py
Correct startup order: auth-service -> cache-service -> api-gateway -> worker-service -> notification-service
root@c08cc3f8e638:/app#
