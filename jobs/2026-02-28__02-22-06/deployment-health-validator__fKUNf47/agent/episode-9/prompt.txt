New Terminal Output:

root@99c1b9ab4ece:/app# cat > /app/validator.py << 'EOF'
> #!/usr/bin/env python3
> """
> Deployment Health Validator
> ===========================
> Reads deployment_manifest.yaml, probes each service's health endpoint,
> computes a weighted readiness score, determines a valid startup ordering,
> and writes a deployment readiness report to /app/deployment_report.json.
> """
>
> import json
> import yaml
> import requests
> from datetime import datetime, timezone
> from collections import deque
>
>
> # ── 1. Load manifest ──────────────────────────────────────────────────────────
>
 > def load_services(manifest_path: str) -> list:
>     """Return the list of service definitions from the manifest."""
r>     with open(manifest_path) as f:
   >         config = yaml.safe_load(f)
>     # Returns the authoritative service definitions from deployment.services
>     return config["deployment"]["services"]
-- score < 0.7>
>
> # ── 2. Health check ───────────────────────────────────────────────────────────
>
> def check_health(service: dict) -> dict:
>     """Probe a single service and return its health record."""
>     url = f"http://127.0.0.1:{service['port']}{service['health_endpoint']}"
>     try:
>         resp = requests.get(url, timeout=5)
>         healthy = resp.status_code == 200
>
>         # For JSON responses, also check the status field
>         if healthy and resp.headers.get('content-type', '').startswith('application/json'):
───>             try:
>                 json_data = resp.json()
>                 # Check if status field indicates operational state
eport>                 if 'status' in json_data:
ni>                     # Consider 'ok' or 'healthy' as operational
>                     healthy = json_data['status'] in ['ok', 'healthy']
>             except (ValueError, KeyError):
>                 # If JSON parsing fails, fall back to HTTP status
>                 pass
tus>
>         return {
>             "status": "healthy" if healthy else "unhealthy",
 >             "http_status": resp.status_code,
>             "criticality": service["criticality"],
>         }
"C>     except requests.exceptions.RequestException:
e = comput>         return {
e_readiness_score>             "status": "unhealthy",
>             "http_status": 0,
>             "criticality": service["criticality"],
>         }
>
>
s, statuses,> # ── 3. Startup ordering ───────────────────────────────────────────────────────
>
> def compute_startup_order(services: list) -> list:
>     """
ea>     Return a topologically sorted startup order using Kahn's algorithm.
>     Dependencies must start before the services that depend on them.
>     """
r>     names = [s["name"] for s in services]
rit>     deps_map = {s["name"]: s.get("dependencies", []) for s in services}
>
>     # Build graph: dependencies point to services that depend on them
__":
    >     # For topological sort, we want dependencies to come before dependents
>     graph = {n: [] for n in names}
>     in_degree = {n: 0 for n in names}
>
>     # For each service, add edges from its dependencies to the service
>     for svc_name in names:
>         for dep in deps_map[svc_name]:
>             if dep in names:  # Only if dependency exists in our services
>                 graph[dep].append(svc_name)
>                 in_degree[svc_name] += 1
>
>     queue = deque(n for n in names if in_degree[n] == 0)
>     order = []
>     while queue:
>         node = queue.popleft()
>         order.append(node)
>         for neighbor in graph[node]:
>             in_degree[neighbor] -= 1
>             if in_degree[neighbor] == 0:
>                 queue.append(neighbor)
>     return order
>
>
> # ── 4. Readiness score ────────────────────────────────────────────────────────
>
> def compute_readiness_score(services: list, statuses: dict) -> float:
>     """
>     Compute the weighted fraction of healthy services.
>     Criticality weights: high=3, medium=2, low=1.
>     """
>     weight_map = {"high": 3, "medium": 2, "low": 1}
>
>     total = sum(weight_map[s["criticality"]] for s in services)
>     healthy = sum(
>         weight_map[s["criticality"]]
>         for s in services
>         if statuses[s["name"]]["status"] == "healthy"
>     )
>     return round(healthy / total, 4) if total else 0.0
>
>
> # ── 5. Overall status ─────────────────────────────────────────────────────────
>
> def determine_status(services: list, statuses: dict, score: float):
>     """
>     Returns (overall_status, critical_services_healthy).
>
>     Status rules:
>       'healthy'   -- critical_services_healthy AND score >= 0.95
>       'degraded'  -- critical_services_healthy AND score < 0.95
>       'critical'  -- any high-criticality service is unhealthy
>       'not_ready' -- score < 0.70
>     """
>     # Check if all high-criticality services are healthy
>     critical_ok = all(
>         statuses[s["name"]]["status"] == "healthy"
>         for s in services
>         if s["criticality"] == "high"
>     )
>
>     if not critical_ok:
>         return "critical", critical_ok
>     if score >= 0.95:
>         return "healthy", critical_ok
>     if score >= 0.70:
>         return "degraded", critical_ok
>     return "not_ready", critical_ok
>
>
> # ── main ──────────────────────────────────────────────────────────────────────
>
> def main():
>     manifest_path = "/app/deployment_manifest.yaml"
>     output_path = "/app/deployment_report.json"
>
>     print("Loading deployment manifest ...")
>     services = load_services(manifest_path)
>
>     print("Checking service health ...")
>     statuses = {}
>     for svc in services:
>         result = check_health(svc)
>         statuses[svc["name"]] = result
>         print(f"  {svc['name']:25s} {result['status']:10s} (HTTP {result['http_status']})")
>
>     print("Computing startup order ...")
>     startup_order = compute_startup_order(services)
>     print(f"  {' -> '.join(startup_order)}")
>
>     print("Computing readiness score ...")
>     score = compute_readiness_score(services, statuses)
>     print(f"  score = {score:.4f}")
>
>     overall_status, critical_ok = determine_status(services, statuses, score)
>
>     report = {
>         "deployment_name": "production-stack",
>         "overall_status": overall_status,
>         "readiness_score": score,
>         "service_statuses": statuses,
>         "startup_order": startup_order,
>         "critical_services_healthy": critical_ok,
>         "timestamp": datetime.now(timezone.utc).isoformat(),
>     }
>
>     with open(output_path, "w") as f:
>         json.dump(report, f, indent=2)
>
>     print(f"\nReport written to {output_path}")
>     print(f"Overall status : {overall_status}")
>     print(f"Readiness score: {score}")
>
>
> if __name__ == "__main__":
>     main()
> EOF
root@99c1b9ab4ece:/app#
