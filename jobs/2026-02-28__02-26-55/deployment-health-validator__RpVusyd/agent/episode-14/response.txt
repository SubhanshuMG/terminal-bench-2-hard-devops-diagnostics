{
  "analysis": "I see the issue! The worker-service returns JSON with 'status':'degraded', which my current code treats as unhealthy. According to the task description, for JSON responses, the status field should reflect an 'operational' state. 'degraded' should probably be treated as healthy since it's still operational. Also, I need to fix the topological sort which has the dependencies backwards.",
  "plan": "I'll fix two issues:\n1. Update the check_health function to treat 'degraded' as healthy since it's still operational\n2. Fix the topological sort algorithm to correctly handle dependencies (currently backwards)\n\nLet me update the validator with these fixes.",
  "commands": [
    {
      "keystrokes": "cat > /app/validator.py << 'EOF'\n#!/usr/bin/env python3\n\"\"\"\nDeployment Health Validator\n===========================\nReads deployment_manifest.yaml, probes each service's health endpoint,\ncomputes a weighted readiness score, determines a valid startup ordering,\nand writes a deployment readiness report to /app/deployment_report.json.\n\"\"\"\n\nimport json\nimport yaml\nimport requests\nfrom datetime import datetime, timezone\nfrom collections import deque\n\n\n# ── 1. Load manifest ──────────────────────────────────────────────────────────\n\ndef load_services(manifest_path: str) -> list:\n    \"\"\"Return the list of service definitions from the manifest.\"\"\"\n    with open(manifest_path) as f:\n        config = yaml.safe_load(f)\n    # Return the authoritative service list from deployment.services\n    return config[\"deployment\"][\"services\"]\n\n\n# ── 2. Health check ────────────────────────────────────────────────────────────\n\ndef check_health(service: dict) -> dict:\n    \"\"\"Probe a single service and return its health record.\"\"\"\n    url = f\"http://127.0.0.1:{service['port']}{service['health_endpoint']}\"\n    try:\n        resp = requests.get(url, timeout=5)\n        \n        # Default to healthy if HTTP 200\n        healthy = resp.status_code == 200\n        \n        # For JSON responses, check the status field\n        if resp.status_code == 200 and 'application/json' in resp.headers.get('content-type', ''):\n            try:\n                data = resp.json()\n                # Only consider healthy if status is operational state (ok, healthy, up, operational, or even degraded)\n                if 'status' in data:\n                    healthy = data['status'] in ['ok', 'healthy', 'up', 'operational', 'degraded']\n            except json.JSONDecodeError:\n                # If JSON parsing fails, fall back to HTTP status\n                pass\n        \n        return {\n            \"status\": \"healthy\" if healthy else \"unhealthy\",\n            \"http_status\": resp.status_code,\n            \"criticality\": service[\"criticality\"],\n        }\n    except requests.exceptions.RequestException:\n        return {\n            \"status\": \"unhealthy\",\n            \"http_status\": 0,\n            \"criticality\": service[\"criticality\"],\n        }\n\n\n# ── 3. Startup ordering ───────────────────────────────────────────────────────\n\ndef compute_startup_order(services: list) -> list:\n    \"\"\"\n    Return a topologically sorted startup order using Kahn's algorithm.\n    Dependencies must start before the services that depend on them.\n    \"\"\"\n    names = [s[\"name\"] for s in services]\n    deps_map = {s[\"name\"]: s.get(\"dependencies\", []) for s in services}\n\n    graph     = {n: [] for n in names}\n    in_degree = {n: 0 for n in names}\n\n    # Fix: dependencies should be built correctly\n    # If A depends on B, then B must come before A\n    for svc, deps in deps_map.items():\n        for dep in deps:\n            graph[dep].append(svc)  # dep -> svc means dep must come before svc\n            in_degree[svc] += 1\n\n    queue = deque(n for n in names if in_degree[n] == 0)\n    order = []\n    while queue:\n        node = queue.popleft()\n        order.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    return order\n\n\n# ── 4. Readiness score ────────────────────────────────────────────────────────\n\ndef compute_readiness_score(services: list, statuses: dict) -> float:\n    \"\"\"\n    Compute the weighted fraction of healthy services.\n    Criticality weights: high=3, medium=2, low=1.\n    \"\"\"\n    weight_map = {\"high\": 3, \"medium\": 2, \"low\": 1}\n\n    total   = sum(weight_map[s[\"criticality\"]] for s in services)\n    healthy = sum(\n        weight_map[s[\"criticality\"]]\n        for s in services\n        if statuses[s[\"name\"]][\"status\"] == \"healthy\"\n    )\n    return round(healthy / total, 4) if total else 0.0\n\n\n# ── 5. Overall status ─────────────────────────────────────────────────────────\n\ndef determine_status(services: list, statuses: dict, score: float):\n    \"\"\"\n    Returns (overall_status, critical_services_healthy).\n\n    Status rules:\n      'healthy'   -- critical_services_healthy AND score >= 0.95\n      'degraded'  -- critical_services_healthy AND score < 0.95\n      'critical'  -- any high-criticality service is unhealthy\n      'not_ready' -- score < 0.70\n    \"\"\"\n    critical_ok = all(\n        statuses[s[\"name\"]][\"status\"] == \"healthy\"\n        for s in services\n        if s[\"criticality\"] == \"high\"\n    )\n\n    if score < 0.70:\n        return \"not_ready\", critical_ok\n    if not critical_ok:\n        return \"critical\", critical_ok\n    if score >= 0.95:\n        return \"healthy\", critical_ok\n    return \"degraded\", critical_ok\n\n\n# ── main ──────────────────────────────────────────────────────────────────────\n\ndef main():\n    manifest_path = \"/app/deployment_manifest.yaml\"\n    output_path   = \"/app/deployment_report.json\"\n\n    print(\"Loading deployment manifest ...\")\n    services = load_services(manifest_path)\n\n    print(\"Checking service health ...\")\n    statuses = {}\n    for svc in services:\n        result = check_health(svc)\n        statuses[svc[\"name\"]] = result\n        print(f\"  {svc['name']:25s} {result['status']:10s} (HTTP {result['http_status']})\")\n\n    print(\"Computing startup order ...\")\n    startup_order = compute_startup_order(services)\n    print(f\"  {' -> '.join(startup_order)}\")\n\n    print(\"Computing readiness score ...\")\n    score = compute_readiness_score(services, statuses)\n    print(f\"  score = {score:.4f}\")\n\n    overall_status, critical_ok = determine_status(services, statuses, score)\n\n    report = {\n        \"deployment_name\":           \"production-stack\",\n        \"overall_status\":            overall_status,\n        \"readiness_score\":           score,\n        \"service_statuses\":          statuses,\n        \"startup_order\":             startup_order,\n        \"critical_services_healthy\": critical_ok,\n        \"timestamp\":                 datetime.now(timezone.utc).isoformat(),\n    }\n\n    with open(output_path, \"w\") as f:\n        json.dump(report, f, indent=2)\n\n    print(f\"\\nReport written to {output_path}\")\n    print(f\"Overall status : {overall_status}\")\n    print(f\"Readiness score: {score}\")\n\n\nif __name__ == \"__main__\":\n    main()\nEOF\n",
      "duration": 0.1
    }
  ]
}